#!/usr/bin/perl
#
# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 Yokogawa Electric Corporation,
# YDC Corporation, IPA (Information-technology Promotion Agency, Japan).
# All rights reserved.
# 
# Redistribution and use of this software in source and binary forms, with 
# or without modification, are permitted provided that the following 
# conditions and disclaimer are agreed and accepted by the user:
# 
# 1. Redistributions of source code must retain the above copyright 
# notice, this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright 
# notice, this list of conditions and the following disclaimer in the 
# documentation and/or other materials provided with the distribution.
# 
# 3. Neither the names of the copyrighters, the name of the project which 
# is related to this software (hereinafter referred to as "project") nor 
# the names of the contributors may be used to endorse or promote products 
# derived from this software without specific prior written permission.
# 
# 4. No merchantable use may be permitted without prior written 
# notification to the copyrighters. However, using this software for the 
# purpose of testing or evaluating any products including merchantable 
# products may be permitted without any notification to the copyrighters.
# 
# 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHTERS, THE PROJECT AND 
# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING 
# BUT NOT LIMITED THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
# FOR A PARTICULAR PURPOSE, ARE DISCLAIMED.  IN NO EVENT SHALL THE 
# COPYRIGHTERS, THE PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
# CONTRACT,STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
# THE POSSIBILITY OF SUCH DAMAGE.
#
# $TAHI: dhcpv6.p2/remote/manual/dhcp6s.rmt,v 1.3 2010/03/29 23:34:22 mario Exp $
#

use V6evalRemote;
use File::Basename;

my $basename	= "Dibbler-srv";
my $prompt	= "$basename> ";


my $CFGFILE_PATH = "/etc/dibbler/server.conf";
my $DUIDFILE_PATH = "/var/lib/dibbler/server-duid";
my $LOGFILE_PATH = "/var/log/dibbler/dibbler-server.log";
my @FILES_PATH = { $LOGFILE_PATH,
		   $CFGFILE_PATH,
		   $DUIDFILE_PATH,
		   "/var/lib/dibbler/server-cache.xml",
		   "/var/lib/dibbler/server-AddrMgr.xml",
		   "/var/lib/dibbler/server-CfgMgr.xml",
		   "/var/lib/dibbler/server-IfaceMgr.xml",
		   "/var/lib/dibbler/server-TransMgr.xml"   
};

print "#### arguments passed to dhcp6s.rmt:";
for my $arg (@ARGV) {
    print $arg ." ";
}
print "\n";

# print "# BEFORE rOpen()=".$V6evalRemote::Device."\n";
rOpen();
# print "# BEFORE rArg()=".$V6evalRemote::Device."\n";
rArg()  || goto error;
# print "# AFTER rArg()=".$V6evalRemote::Device."\n";
# print "# rOpt_link0=". $rOpt_link0."\n";

print "\n";
if(defined($rOpt_start)){
	if (!defined($rOpt_link0) ){
	print "lio_start". "\n";
	print $prompt."NG:The interface used by Dibbler Server test has not been defined in the configuration file.";
	print $prompt."Please define it!";
	print "lio_stop". "\n"; 
	goto error;
	}

	open(CFG, ">server.conf") or die("Failed to create server.conf: $!");
	print CFG "# server.conf for Dibbler-server. Autogenerated by TAHI tests.\n";
	print CFG "# It will be overwritten with the next test. Do not edit!\n\n";
	print CFG "log-level 8\n";
	print CFG "log-mode full\n";
	print CFG "\n";

	print "lio_start". "\n";
	print $prompt . "Set parameters of Dibbler Server manually as following:\n\n";

	if(defined($rOpt_stateless)){
	    print CFG "stateless\n";
	}

	if(defined($rOpt_duid)){
	print  $prompt."Please set the DUID type using by Server to $rOpt_duid.\n";
	}


	if(defined($rOpt_link0) ){
	    print CFG "iface $rOpt_link0 {\n";
	}

	# TODO: Duid is written to /var/lib/dibbler/server-duid
	if(defined($rOpt_valduid)){
	    open(DUID, ">server-duid") or die("Failed to create server-duid file: $!");
	    print DUID "$rOpt_valduid";
	    close(DUID);
	} else {
	    unlink("server-duid");
	}

	if(defined($rOpt_preference)){
	    if("default" eq $rOpt_preference){
		#print  $prompt."Please set the Server Preference value to default value.\n";
	    }
	    else{
		print CFG "    preference ".$rOpt_preference."\n";
		#print  $prompt."Please set the Server Preference value to $rOpt_preference.\n";
	    }
	}
	
	if(defined($rOpt_startaddr) && (defined($rOpt_endaddr))){
	    print CFG "    preferred-lifetime 10000\n";
	    print CFG "    valid-lifetime 20000\n";
	    print CFG "    t1 5000\n";
	    print CFG "    t2 16000\n";

	    print CFG "    class {\n";
	    print CFG "        pool ".$rOpt_startaddr." - ".$rOpt_endaddr."\n";
	    print CFG "    }\n";
	}

	if(defined($rOpt_reconf)){
	    # NOT SUPPORTED by Dibbler
	print  $prompt."Please enable the Reconfigure.\n";
	}

	if(defined($rOpt_rapidcommit)){
		print CFG "    rapid-commit true\n";
	}

	if(defined($rOpt_allowoptions)){
	    # Not supported by Dibbler
		print  $prompt."Please set the server to allow the option: $rOpt_allowoptions.\n";
	}

	if(defined($rOpt_onlypermit)){
	    # Not supported by Dibbler
	    print  $prompt."Please set the server which only allows the option: $rOpt_onlypermit.\n";
	}

	if(defined($rOpt_sendoptions)){
	    print CFG "    option ".$rOpt_sendoptions." string \"customoption.example.org\"\n";
	}

	if(defined($rOpt_authentication)){
	    # Not supported by Dibbler
		print  $prompt."Please set the Authentication protocol:";
		if($rOpt_authentication eq "delayed"){
			print  $prompt."Delayed Authentication Protocol.\n";
		}
		elsif($rOpt_authentication eq "reconfigure"){
			print  $prompt."Reconfigure Key Authentication Protocol.\n";
		}
		else{
			print  $prompt."$rOpt_authentication.\n";
		}
		print $prompt."Please set the Authentication parameter.\n";
		print $prompt."\tREALM:  $rOpt_auth_realm\n";
		print $prompt."\tKey ID: $rOpt_auth_keid\n";
		print $prompt."\tShared Secret Key: $rOpt_auth_sharedsecretkey\n";
	}

        if("notset" eq $rOpt_delegateprefix){
        	print  CFG "# prefix delegation disabled.\n";
        }
        elsif(defined($rOpt_delegateprefix) && defined($rOpt_delegateprefixlength)){
	    print CFG "    pd-class {\n";
	    print CFG "        pd-pool ".$rOpt_delegateprefix."/".$rOpt_delegateprefixlength."\n";
	    #print  $prompt."Please set server with the delegate prefix: $rOpt_delegateprefix.\n";
	    #print  $prompt."And the length of prefix: $rOpt_delegateprefixlength.\n";
	    if(defined($rOpt_additional_delegateprefix)){
        		print  $prompt."Please set server with the additional delegate prefix: $rOpt_additional_delegateprefix.\n";
        		print  $prompt."And the length of prefix: $rOpt_delegateprefixlength.\n";
	    }
	    if (defined($rOpt_renewtime)){
		print CFG "        t1 ".$rOpt_renewtime."\n";
		#print  $prompt."Please set the T1 of IA_PD option to $rOpt_renewtime.\n";
	    }
	    else{
		print CFG "        t1 500\n";
		#print  $prompt."Please set the T1 of IA_PD to 500.\n";
	    }
	    if (defined($rOpt_rebindtime)){
		print CFG "        t2 ".$rOpt_rebindtime."\n";
		#print  $prompt."Please set the T2 of IA_PD option to $rOpt_rebindtime.\n";
	    }
	    else{
		print CFG "        t2 800\n";
		#print  $prompt."Please set the T2 of IA_PD to 800.\n";
	    }
	    
                #if (defined($rOpt_pltimeiapd)){
                if (defined($rOpt_preferredlifetime)){
                #       print  $prompt."Please set the preferred time of IA_PD prefix option to $rOpt_pltimeiapd.\n";
                        print  $prompt."Please set the preferred time of IA_PD prefix option to $rOpt_preferredlifetime.\n";
                #       if(defined($rOpt_vltimeiapd)){
                        if(defined($rOpt_validlifetime)){
                #       print  $prompt."Please set the valid time of IA_PD prefix option to $rOpt_vltimeiapd.\n";
                        print  $prompt."Please set the valid time of IA_PD prefix option to $rOpt_validlifetime.\n";
                        }
                }
                #   In a message sent by a delegating router the preferred and valid
                #   lifetimes should be set to the values of AdvPreferredLifetime and
                #   AdvValidLifetime as specified in section 6.2.1, "Router Configuration
                #   Variables" of RFC 2461 [4], unless administratively configured.
                else{
                        print  $prompt."Please set the preferred time of IA_PD prefix option to the default value AdvPreferredLifetime(604800 s).\n";
                        print  $prompt."Please set the valid time of IA_PD prefix option to the default value AdvValidLifetime(2592000 s).\n";
                }
	    print CFG "    }\n"; # end of pd-class
	}
        if(defined($rOpt_other_delegateprefix) && defined($rOpt_delegateprefixlength)){
        	print  $prompt."Please set server with the other delegate prefix: $rOpt_other_delegateprefix.\n";
        	print  $prompt."And the length of prefix: $rOpt_other_delegateprefixlength.\n";
                if (defined($rOpt_renewtime)){
                        print  $prompt."Please set the T1 of IA_PD option to $rOpt_renewtime.\n";
                }
                else{
                        print  $prompt."Please set the T1 of IA_PD to 500.\n";
                }
                if (defined($rOpt_rebindtime)){
                        print  $prompt."Please set the T2 of IA_PD option to $rOpt_rebindtime.\n";
                }
                else{
                        print  $prompt."Please set the T2 of IA_PD to 800.\n";
                }
                #if (defined($rOpt_pltimeiapd)){
                if (defined($rOpt_preferredlifetime)){
                #       print  $prompt."Please set the preferred time of IA_PD prefix option to $rOpt_pltimeiapd.\n";
                        print  $prompt."Please set the preferred time of IA_PD prefix option to $rOpt_preferredlifetime.\n";
                #       if(defined($rOpt_vltimeiapd)){
                        if(defined($rOpt_validlifetime)){
                #       print  $prompt."Please set the valid time of IA_PD prefix option to $rOpt_vltimeiapd.\n";
                        print  $prompt."Please set the valid time of IA_PD prefix option to $rOpt_validlifetime.\n";
                        }
                }
                #   In a message sent by a delegating router the preferred and valid
                #   lifetimes should be set to the values of AdvPreferredLifetime and
                #   AdvValidLifetime as specified in section 6.2.1, "Router Configuration
                #   Variables" of RFC 2461 [4], unless administratively configured.
                else{
                        print  $prompt."Please set the preferred time of IA_PD prefix option to the default value AdvPreferredLifetime(604800 s).\n";
                        print  $prompt."Please set the valid time of IA_PD prefix option to the default value AdvValidLifetime(2592000 s).\n";
                }
        }



	if(defined($rOpt_delegateprefix2) && defined($rOpt_length2)){
		print  $prompt."\n";
		print  $prompt."Please set server with the next delegate prefix: $rOpt_delegateprefix2.\n";
		print  $prompt."And the length of prefix: $rOpt_length2.\n"; 
		print  $prompt."Please set the T1 of IA_PD to 500.\n";
		print  $prompt."Please set the T2 of IA_PD to 800.\n";
		print  $prompt."Please set the preferred time of IA_PD prefix option to the default value AdvPreferredLifetime(604800 s).\n";
		print  $prompt."Please set the valid time of IA_PD prefix option to the default value AdvValidLifetime(2592000 s).\n";
 	}

	if(defined($rOpt_dns)){
	    print CFG "    option dns-server $rOpt_dns\n";
	}

	if(defined($rOpt_domainlist)){
	    print CFG "    option domain $rOpt_domainlist\n";
	}

	if(defined($rOpt_sipd)){
	    print CFG "    option sip-domain $rOpt_sipd\n";
	}

	if(defined($rOpt_sipa)){
	    print CFG "    option sip-server $rOpt_sipa\n";
	}

	print CFG "}\n";
	close(CFG);

	send_file("server.conf", $CFGFILE_PATH);
	if (defined($rOpt_valduid)) {
	    send_file("server-duid", $DUIDFILE_PATH);
	}
	
# ---------------Begin start---------------------------
	linux_start_dibbler_server();
	print $prompt."Dibbler server started. Please verify!\n";
	print  $prompt."Then press the Enter.\a\n";
	#print "lio_stop". "\n";

}
elsif(defined($rOpt_stop)){
	#print "lio_start". "\n";
	linux_stop_dibbler_server();
	print $prompt."Please stop the Dibbler Server!\n";
	print  $prompt."Then press the Enter.\a\n";
	#print "lio_stop". "\n";
}
elsif(defined($rOpt_restart)){
	#print "lio_start". "\n";
	linux_stop_dibbler_server();
	linux_start_dibbler_server();
	print $prompt."Please restart the Dibbler Server!\n";
	print  $prompt."Then press the Enter.\a\n";
	#print "lio_stop". "\n";
}

#<STDIN>;

rClose();
exit($V6evalRemote::exitPass);


error:
    rClose();
    exit($V6evalRemote::exitFail);

sub linux_start_dibbler_server()
{
    print "Starting dibbler-server\n";
    my $cmd = "dibbler-server start";
    my $status = rCommand($cmd, 5);
    my $output = rCmdOutput();
    if ($status != 1) {
	print "Failed to execute [".$cmd."]. Output:\n";
	print "---remote-output-start----------\n";
	print $output."\n";
	print "---remote-output-end------------\n";
	return(0);
    }
    if ($V6evalRemote::debug) {
	print "---remote-output-start----------\n";
	print $output."\n";
	print "---remote-output-end------------\n";
    }
    return (1);
}

sub linux_stop_dibbler_server()
{
    print "Stopping dibbler-server\n";
    my $cmd = "dibbler-server stop";
    my $status = rCommand($cmd, 5);
    my $output = rCmdOutput();
    if ($status != 1) {
	print "Failed to execute [".$cmd."]. Output:\n";
	print "---remote-output-start----------\n";
	print $output."\n";
	print "---remote-output-end------------\n";
	return(0);
    }
    if ($V6evalRemote::debug) {
	print "---remote-output-start----------\n";
	print $output."\n";
	print "---remote-output-end------------\n";
    }
    return (1);
}

sub send_file() {
    my($from_local, $to_remote, $timeout)=@_;

    my $use_rPutfile = 0;

    if ($use_rPutfile) {

	my $result = rPutfile($from_local, $to_remote, 5);
	print "Sent file ".$from_local." to ".$to_remote.", timeout=5, result=".$result."\n";
    } else {
    
	my $content = "";
	if (!open(CFG, $from_local)) { 
	    print "Failed to open server.conf $!"; goto error; 
	}
    
	while (<CFG>) {
	    $content .= $_;
	}
	close(CFG);
	$cmd = "/bin/echo \"".$content."\" > ".$to_remote;
	$result = rCommand($cmd, 5);
	print "Sent file ".$from_local." to ".$to_remote.", timeout=5, result=".$result."\n";
    }
}


__END__

=head1 NAME

B<XXX.rmt> - XXX

=head1 SYNOPSIS

B<XXX.rmt> [-commonoption ...] [XXX=XXX] [XXX="XXX"]

=head1 DESCRIPTION

B<XXX.rmt> XXX
Default timeout value is five seconds.
Do ``perldoc V6evalRemote'' for common options.

B<ifs> option works only if B<target type> is "nec-libra".

=head1 RETURN VALUES

The B<cleardefr.rmt> exits with one of the following values:
 0  command completed successfully
 1  command failed

=head1 SEE ALSO

perldoc V6evalRemote

=cut
